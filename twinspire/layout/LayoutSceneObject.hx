/**
* Generated by Claude AI on 2025-08-12 and adapted for use
**/

package twinspire.layout;

import twinspire.scenes.SceneObject;
import twinspire.scenes.Scene;
import twinspire.render.GraphicsContext;
import twinspire.render.UpdateContext;
import twinspire.DimIndex;
import twinspire.Id;
import twinspire.geom.Dim;

import kha.Image;

/**
 * SceneObject that contains layout information
 */
class LayoutSceneObject extends SceneObject {

    // states if generating images to cache
    private var _states:Array<Image>;

    public var layout:Layout;
    public var result:LayoutResult;
    public var autoReapply:Bool = true;
    
    /**
     * Cached references for quick access in update/render
     */
    private var cachedRefs:Map<String, DimIndex>;
    
    public function new(?id:Id) {
        super();
        this.type = id ?? Id.None;
        cachedRefs = [];
        _states = [];
    }
    
    /**
     * Initialize from an existing layout
     */
    public function initFromLayout(layout:Layout, ctx:GraphicsContext):LayoutResult {
        this.layout = layout;
        this.result = layout.apply(ctx);
        updateCachedRefs();
        return result;
    }
    
    /**
     * Get a dimension index by name (cached for performance)
     */
    public function getRef(name:String):DimIndex {
        if (!cachedRefs.exists(name) && result != null) {
            cachedRefs[name] = result.get(name);
        }
        return cachedRefs[name];
    }
    
    /**
     * Reapply layout after modifications
     */
    public function reapply(ctx:GraphicsContext):LayoutResult {
        if (layout != null) {
            result = layout.apply(ctx, result);
            updateCachedRefs();
        }
        return result;
    }
    
    /**
     * Update cached references after reapply
     */
    private function updateCachedRefs() {
        // Clear and rebuild cache
        for (key in cachedRefs.keys()) {
            cachedRefs[key] = result.get(key);
        }
    }
    
    /**
     * Mark that layout needs reapplying
     */
    public function markDirty() {
        if (autoReapply) {
            var ctx = Application.instance.graphicsCtx;
            reapply(ctx);
        }
    }

    /**
    * Adds a state to this object and returns the index.
    **/
    public function addState(image:Image) {
        return _states.push(image) - 1;
    }

    /**
    * Get a state image at the given index.
    **/
    public function getState(index:Int):Image {
        if (index < 0 || index >= _states.length) {
            return null;
        }

        return _states[index];
    }

    /**
    * Removes a state with the given index.
    **/
    public function removeState(index:Int) {
        if (index < 0 || index >= _states.length) {
            return;
        }

        _states.splice(index, 1);
    }

    /**
    * Gets the state from the name of a `DimIndex` reference.
    **/
    public function getStateFromName(name:String) {
        
    }

}