/**
* This document was generated by Claude AI on 2025-08-12, adapted from the original code.
**/

package twinspire.layout;

import twinspire.layout.Layout.NamedDimRef;
import twinspire.render.GraphicsContext;
import kha.math.FastVector2;
import twinspire.DimIndex;

/**
 * Layout constraint types
 */
enum LayoutConstraint {
    HorizontalFlow(container:Int, children:Array<Int>, spacing:Float);
    VerticalFlow(container:Int, children:Array<Int>, spacing:Float);
    GridLayout(container:Int, columns:Array<GridSize>, rows:Array<GridSize>, children:Array<Int>);
    StackLayout(container:Int, children:Array<Int>);
    ScrollContainer(container:Int, children:Array<Int>);
    ClippedContainer(container:Int, children:Array<Int>);
    Padding(wrapper:Int, child:Int, top:Float, right:Float, bottom:Float, left:Float);
    MergedLayout(wrapper:Int, children:Array<Int>);
    Align(target:Int, reference:Int, alignment:LayoutAlignment);
    Position(target:Int, x:Float, y:Float);
    Size(target:Int, width:Float, height:Float);
}

/**
 * Grid sizing options
 */
enum GridSize {
    Fixed(pixels:Float);
    Percent(value:Float);
    Auto;
}

/**
 * Layout alignment options
 */
enum LayoutAlignment {
    Center;
    TopLeft;
    TopCenter;
    TopRight;
    MiddleLeft;
    MiddleRight;
    BottomLeft;
    BottomCenter;
    BottomRight;
}

/**
 * Reference to a layout dimension for chaining operations
 */
class LayoutRef {
    private var layout:Layout;
    public var index(default, null):NamedDimRef;
    
    public function new(layout:Layout, index:NamedDimRef) {
        this.layout = layout;
        this.index = index;
    }
    
    public function align(alignment:LayoutAlignment, ?relativeTo:LayoutRef):LayoutRef {
        var refIndex = relativeTo != null ? relativeTo.index.index : -1;
        layout.constraints.push(Align(index.index, refIndex, alignment));
        return this;
    }
    
    public function at(x:Float, y:Float):LayoutRef {
        layout.constraints.push(Position(index.index, x, y));
        return this;
    }
    
    public function size(width:Float, height:Float):LayoutRef {
        layout.constraints.push(Size(index.index, width, height));
        return this;
    }
    
    public function offset(x:Float, y:Float):LayoutRef {
        var current = layout.dims[index.index];
        layout.constraints.push(Position(index.index, current.x + x, current.y + y));
        return this;
    }
    
    public function pad(padding:Float):LayoutRef {
        return layout.pad(this, padding);
    }
    
    public function pad4(top:Float, right:Float, bottom:Float, left:Float):LayoutRef {
        return layout.pad4(this, top, right, bottom, left);
    }
}

/**
 * Result of applying layout to GraphicsContext
 */
class LayoutResult {
    public var indices:Map<Int, DimIndex>;
    public var named:Map<String, NamedDimRef>;
    public var containerIndices:Map<Int, Int>;
    private var layout:Layout;
    
    public function new(indices:Map<Int, DimIndex>, named:Map<String, NamedDimRef>, containerIndices:Map<Int, Int>, layout:Layout) {
        this.indices = indices;
        this.named = named;
        this.containerIndices = containerIndices;
        this.layout = layout;
    }
    
    public function get(name:String):DimIndex {
        var layoutIndex = named[name].index;
        return layoutIndex != null ? indices[layoutIndex] : null;
    }
    
    public function getIndex(layoutIndex:Int):DimIndex {
        return indices[layoutIndex];
    }
    
    /**
     * Reapply the layout after modifications
     */
    public function reapply(ctx:GraphicsContext):LayoutResult {
        return layout.apply(ctx, this);
    }
}

class LayoutTypes {}