/**
* This document was generated by Claude AI on 2025-08-12, adapted from the original code.
**/

package twinspire.layout;

import twinspire.render.vector.VectorSpace;
using twinspire.layout.LayoutTypes;

import kha.Font;
import kha.System;
import kha.math.FastVector2;
import twinspire.geom.Dim;
import twinspire.render.GraphicsContext;
import twinspire.Id;
import twinspire.DimIndex;
using twinspire.extensions.ArrayExtensions;

typedef NamedDimRef = {
    var index:Int;
    var type:Id;
    var space:VectorSpace;
}

/**
 * Functional Layout API - Low-level dimension generation and manipulation
 */
class Layout {
    // do not touch
    public var dims:Array<Dim>;
    // do not touch
    public var constraints:Array<LayoutConstraint>;

    private var namedDims:Map<String, NamedDimRef>;
    private var deleted:Array<Int>;
    private var containers:Array<ContainerInfo>;
    private var textContent:Map<Int, String>;
    private var textFonts:Map<Int, {font:Font, size:Int}>;
    
    public function new() {
        dims = [];
        constraints = [];
        namedDims = [];
        deleted = [];
        containers = [];
        textContent = [];
        textFonts = [];
    }
    
    /**
     * Create a dimension with optional naming for later reference
     */
    public function dim(width:Float, height:Float, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var d = new Dim(0, 0, width, height);
        var index = dims.push(d) - 1;
        var dimRef:NamedDimRef = {
            index: index,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = dimRef;
        }
        
        return new LayoutRef(this, dimRef);
    }
    
    /**
     * Create dimension from text measurement
     */
    public function text(str:String, font:Font, size:Int, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var textDim = Dimensions.getTextDim(font, size, str);
        var index = dims.push(textDim) - 1;
        var textRef:NamedDimRef = {
            index: index,
            type: type != null ? type : Id.None,
            space: space
        };
        
        // Store text content and font info for later updates
        textContent[index] = str;
        textFonts[index] = {font: font, size: size};
        
        if (name != null) {
            namedDims[name] = textRef;
        }
        
        return new LayoutRef(this, textRef);
    }
    
    /**
     * Update text content without rebuilding
     */
    public function updateText(name:String, newText:String):Bool {
        if (!namedDims.exists(name)) return false;

        var index = namedDims[name].index;
        if (index == null || !textFonts.exists(index)) return false;
        
        var fontInfo = textFonts[index];
        var textDim = Dimensions.getTextDim(fontInfo.font, fontInfo.size, newText);
        dims[index].width = textDim.width;
        dims[index].height = textDim.height;
        textContent[index] = newText;
        
        return true;
    }

    /**
    * Get text content
    **/
    public function getText(name:String):String {
        if (!namedDims.exists(name)) {
            return null;
        }

        var index = namedDims[name].index;
        if (!textContent.exists(index)) {
            return null;
        }

        return textContent[index];
    }
    
    /**
     * Create a horizontal box layout
     */
    public function hbox(items:Array<LayoutRef>, ?spacing:Float = 0, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var container = new Dim(0, 0, 0, 0);
        var containerIndex = dims.push(container) - 1;
        var containerRef:NamedDimRef = {
            index: containerIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = containerRef;
        }
        
        constraints.push(HorizontalFlow(containerIndex, items.map(r -> r.index.index), spacing));
        
        return new LayoutRef(this, containerRef);
    }
    
    /**
     * Create a vertical box layout
     */
    public function vbox(items:Array<LayoutRef>, ?spacing:Float = 0, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var container = new Dim(0, 0, 0, 0);
        var containerIndex = dims.push(container) - 1;
        var containerRef:NamedDimRef = {
            index: containerIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = containerRef;
        }
        
        constraints.push(VerticalFlow(containerIndex, items.map(r -> r.index.index), spacing));
        
        return new LayoutRef(this, containerRef);
    }
    
    /**
     * Create a grid layout with percentages or fixed sizes
     */
    public function grid(columns:Array<GridSize>, rows:Array<GridSize>, items:Array<LayoutRef>, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var container = new Dim(0, 0, 0, 0);
        var containerIndex = dims.push(container) - 1;
        var containerRef:NamedDimRef = {
            index: containerIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = containerRef;
        }
        
        constraints.push(GridLayout(containerIndex, columns, rows, items.map(r -> r.index.index)));
        
        return new LayoutRef(this, containerRef);
    }
    
    /**
     * Create a stack where items overlap
     */
    public function stack(items:Array<LayoutRef>, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var container = new Dim(0, 0, 0, 0);
        var containerIndex = dims.push(container) - 1;
        var containerRef:NamedDimRef = {
            index: containerIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = containerRef;
        }
        
        constraints.push(StackLayout(containerIndex, items.map(r -> r.index.index)));
        
        return new LayoutRef(this, containerRef);
    }
    
    /**
     * Create a scrollable container
     */
    public function scrollable(items:Array<LayoutRef>, width:Float, height:Float, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var container = new Dim(0, 0, width, height);
        var containerIndex = dims.push(container) - 1;
        var containerRef:NamedDimRef = {
            index: containerIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = containerRef;
        }
        
        containers.push({
            index: containerIndex,
            children: items.map(r -> r.index.index),
            scrollable: true,
            clipContent: true
        });
        
        constraints.push(ScrollContainer(containerIndex, items.map(r -> r.index.index)));
        
        return new LayoutRef(this, containerRef);
    }
    
    /**
     * Create a clipped container (no scroll)
     */
    public function clipped(items:Array<LayoutRef>, width:Float, height:Float, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var container = new Dim(0, 0, width, height);
        var containerIndex = dims.push(container) - 1;
        var containerRef:NamedDimRef = {
            index: containerIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = containerRef;
        }
        
        containers.push({
            index: containerIndex,
            children: items.map(r -> r.index.index),
            scrollable: false,
            clipContent: true
        });
        
        constraints.push(ClippedContainer(containerIndex, items.map(r -> r.index.index)));
        
        return new LayoutRef(this, containerRef);
    }
    
    /**
     * Apply padding around a dimension
     */
    public function pad(ref:LayoutRef, padding:Float):LayoutRef {
        return pad4(ref, padding, padding, padding, padding);
    }
    
    public function pad4(ref:LayoutRef, top:Float, right:Float, bottom:Float, left:Float):LayoutRef {
        var wrapper = new Dim(0, 0, 0, 0);
        var wrapperIndex = dims.push(wrapper) - 1;
        var wrapperRef:NamedDimRef = {
            index: wrapperIndex,
            type: Id.None,
            space: null
        };
        
        constraints.push(Padding(wrapperIndex, ref.index.index, top, right, bottom, left));
        
        return new LayoutRef(this, wrapperRef);
    }
    
    /**
     * Get a reference to a named dimension for modifications
     */
    public function get(name:String):LayoutRef {
        var index = namedDims[name];
        if (index == null) {
            throw 'No dimension named "$name" found';
        }
        return new LayoutRef(this, index);
    }
    
    /**
     * Remove an element by name
     */
    public function remove(name:String):Bool {
        var index = namedDims[name].index;
        if (index == null) return false;
        
        deleted.push(index);
        namedDims.remove(name);
        
        for (constraint in constraints) {
            switch (constraint) {
                case VerticalFlow(_, children, _) | HorizontalFlow(_, children, _):
                    children.remove(index);
                    
                case GridLayout(_, _, _, children) | StackLayout(_, children):
                    children.remove(index);
                    
                case ScrollContainer(_, children) | ClippedContainer(_, children):
                    children.remove(index);
                    
                default:
            }
        }
        
        return true;
    }
    
    /**
     * Add to an existing container
     */
    public function addTo(containerName:String, ref:LayoutRef):LayoutRef {
        var containerIdx = namedDims[containerName].index;
        if (containerIdx == null) {
            throw 'Container "$containerName" not found';
        }
        
        for (constraint in constraints) {
            switch (constraint) {
                case VerticalFlow(c, children, _) if (c == containerIdx):
                    children.push(ref.index.index);
                    break;
                    
                case HorizontalFlow(c, children, _) if (c == containerIdx):
                    children.push(ref.index.index);
                    break;
                    
                case ScrollContainer(c, children) if (c == containerIdx):
                    children.push(ref.index.index);
                    break;
                    
                case ClippedContainer(c, children) if (c == containerIdx):
                    children.push(ref.index.index);
                    break;
                    
                default:
            }
        }
        
        // Also update container info if it exists
        for (container in containers) {
            if (container.index == containerIdx) {
                container.children.push(ref.index.index);
                break;
            }
        }
        
        return ref;
    }
    
    /**
     * Modify an existing dimension
     */
    public function modify(name:String):LayoutRef {
        var index = namedDims[name];
        if (index == null) {
            throw 'Dimension "$name" not found';
        }
        return new LayoutRef(this, index);
    }
    
    /**
     * Merge another layout into this one
     */
    public function merge(other:Layout, ?at:LayoutRef, ?name:String, ?type:Id, ?space:VectorSpace):LayoutRef {
        var baseIndex = dims.length;
        var indexMap:Map<Int, Int> = [];
        
        // Copy all dimensions from other layout
        for (i in 0...other.dims.length) {
            if (other.deleted.indexOf(i) > -1) continue;
            
            var newDim = other.dims[i].clone();
            var newIndex = dims.push(newDim) - 1;
            indexMap[i] = newIndex;
            
            // Copy text content if exists
            if (other.textContent.exists(i)) {
                textContent[newIndex] = other.textContent[i];
                textFonts[newIndex] = other.textFonts[i];
            }
        }
        
        // Remap constraints to new indices
        for (constraint in other.constraints) {
            constraints.push(remapConstraint(constraint, indexMap));
        }
        
        // Remap named dimensions
        for (key => value in other.namedDims) {
            var prefixedKey = name != null ? name + "_" + key : key;
            if (indexMap.exists(value.index)) {
                namedDims[prefixedKey] = {
                    index: indexMap[value.index],
                    type: value.type,
                    space: value.space
                };
            }
        }
        
        // Remap containers
        for (container in other.containers) {
            if (indexMap.exists(container.index)) {
                containers.push({
                    index: indexMap[container.index],
                    children: container.children.map(c -> indexMap.exists(c) ? indexMap[c] : -1)
                        .filter(c -> c != -1),
                    scrollable: container.scrollable,
                    clipContent: container.clipContent
                });
            }
        }
        
        // Create a wrapper dim for the merged layout
        var wrapperDim = new Dim(0, 0, 0, 0);
        var wrapperIndex = dims.push(wrapperDim) - 1;
        var wrapper:NamedDimRef = {
            index: wrapperIndex,
            type: type != null ? type : Id.None,
            space: space
        };
        
        if (name != null) {
            namedDims[name] = wrapper;
        }
        
        // Position relative to anchor if provided
        if (at != null) {
            constraints.push(Align(wrapperIndex, at.index.index, TopLeft));
        }
        
        // Make all merged dims children of wrapper
        var mergedIndices = [for (key in indexMap.keys()) indexMap[key]];
        if (mergedIndices.length > 0) {
            constraints.push(MergedLayout(wrapperIndex, mergedIndices));
        }
        
        return new LayoutRef(this, wrapper);
    }
    
    /**
     * Add a sub-layout as a child
     */
    public function embed(other:Layout, ?name:String, ?type:Id):LayoutRef {
        return merge(other, null, name, type);
    }
    
    /**
     * Clone this layout
     */
    public function clone():Layout {
        var cloned = new Layout();
        cloned.dims = dims.copy();
        cloned.constraints = constraints.copy();
        cloned.namedDims = namedDims.copy();
        cloned.deleted = deleted.copy();
        cloned.containers = containers.copy();
        cloned.textContent = textContent.copy();
        cloned.textFonts = textFonts.copy();
        return cloned;
    }
    
    /**
     * Solve all constraints and apply to GraphicsContext
     */
    public function apply(ctx:GraphicsContext, ?previous:LayoutResult):LayoutResult {
        solve();
        
        var indices:Map<Int, DimIndex> = [];
        var containerIndices:Map<Int, Int> = [];
        
        if (previous != null) {
            // Remove deleted dimensions
            for (deletedIdx in deleted) {
                if (previous.indices.exists(deletedIdx)) {
                    ctx.removeIndices([previous.indices[deletedIdx]]);
                }
            }
        }
        
        // First pass: Add/update all dimensions
        for (i in 0...dims.length) {
            if (deleted.indexOf(i) > -1) continue;
            
            var nameRef:NamedDimRef = null;
            for (_ => value in namedDims) {
                if (value.index == i) {
                    nameRef = value;
                    break;
                }
            }

            var isContainer = containers.find(c -> c.index == i) != null;
            
            if (previous != null && previous.indices.exists(i)) {
                // Update existing
                var dimIndex = previous.indices[i];
                updateDimension(ctx, dimIndex, dims[i]);
                indices[i] = dimIndex;
                
                if (isContainer && previous.containerIndices.exists(i)) {
                    containerIndices[i] = previous.containerIndices[i];
                }
            } else {
                if (nameRef != null) {
                    ctx.beginVectorSpace(nameRef.space);
                }

                // Add new dimension
                if (isContainer) {
                    var containerIdx = ctx.addContainer(dims[i], nameRef != null ? nameRef.type : Id.None);
                    indices[i] = containerIdx.dimIndex;
                    containerIndices[i] = containerIdx.containerIndex;
                } else {
                    indices[i] = ctx.addUI(dims[i], nameRef != null ? nameRef.type : Id.None);
                }

                if (nameRef != null) {
                    ctx.endVectorSpace();
                }
            }
        }
        
        // Second pass: Link children to containers
        for (container in containers) {
            if (deleted.indexOf(container.index) > -1) continue;
            
            var containerDimIndex = indices[container.index];
            var containerIdx = switch(containerDimIndex) {
                case Direct(idx): idx;
                case Group(idx): throw "Container cannot be a group";
            };
            
            for (childIdx in container.children) {
                // if (deleted.indexOf(childIdx) > -1) continue;
                // if (!indices.exists(childIdx)) continue;
                
                // var childDimIndex = indices[childIdx];
                // switch(childDimIndex) {
                //     case Direct(idx):
                //         ctx.setupDirectLink(childDimIndex, containerIdx);
                //     case Group(idx):
                //         ctx.setupGroupLinksToIndex(childDimIndex, containerIdx);
                // }
            }
        }
        
        deleted = [];
        
        return new LayoutResult(indices, namedDims, containerIndices, this);
    }
    
    /**
     * Solve constraints to calculate final positions
     */
    private function solve() {
        // First pass: calculate sizes
        for (constraint in constraints) {
            switch (constraint) {
                case HorizontalFlow(container, children, spacing):
                    solveHorizontalFlow(container, children, spacing);
                    
                case VerticalFlow(container, children, spacing):
                    solveVerticalFlow(container, children, spacing);
                    
                case GridLayout(container, columns, rows, children):
                    solveGrid(container, columns, rows, children);
                    
                case StackLayout(container, children):
                    solveStack(container, children);
                    
                case ScrollContainer(container, children) | ClippedContainer(container, children):
                    solveContainer(container, children);
                    
                case Padding(wrapper, child, top, right, bottom, left):
                    solvePadding(wrapper, child, top, right, bottom, left);
                    
                case MergedLayout(wrapper, children):
                    solveMerged(wrapper, children);
                    
                case Position(target, x, y):
                    dims[target].x = x;
                    dims[target].y = y;
                    
                case Size(target, width, height):
                    dims[target].width = width;
                    dims[target].height = height;
                    
                case Align(target, reference, alignment):
                    // Handled in second pass
            }
        }
        
        // Second pass: handle alignments after sizes are known
        for (constraint in constraints) {
            switch (constraint) {
                case Align(target, reference, alignment):
                    solveAlignment(target, reference, alignment);
                default:
            }
        }
    }
    
    private function solveHorizontalFlow(containerIdx:Int, children:Array<Int>, spacing:Float) {
        if (deleted.indexOf(containerIdx) > -1) return;
        
        var x = dims[containerIdx].x;
        var maxHeight = 0.0;
        
        for (i in 0...children.length) {
            if (deleted.indexOf(children[i]) > -1) continue;
            
            var child = dims[children[i]];
            child.x = x;
            child.y = dims[containerIdx].y;
            x += child.width + (i < children.length - 1 ? spacing : 0);
            maxHeight = Math.max(maxHeight, child.height);
        }
        
        dims[containerIdx].width = x - dims[containerIdx].x;
        dims[containerIdx].height = maxHeight;
    }
    
    private function solveVerticalFlow(containerIdx:Int, children:Array<Int>, spacing:Float) {
        if (deleted.indexOf(containerIdx) > -1) return;
        
        var y = dims[containerIdx].y;
        var maxWidth = 0.0;
        
        for (i in 0...children.length) {
            if (deleted.indexOf(children[i]) > -1) continue;
            
            var child = dims[children[i]];
            child.x = dims[containerIdx].x;
            child.y = y;
            y += child.height + (i < children.length - 1 ? spacing : 0);
            maxWidth = Math.max(maxWidth, child.width);
        }
        
        dims[containerIdx].width = maxWidth;
        dims[containerIdx].height = y - dims[containerIdx].y;
    }
    
    private function solveGrid(containerIdx:Int, columns:Array<GridSize>, rows:Array<GridSize>, children:Array<Int>) {
        if (deleted.indexOf(containerIdx) > -1) return;
        
        var container = dims[containerIdx];
        var colWidths = calculateGridSizes(columns, container.width);
        var rowHeights = calculateGridSizes(rows, container.height);
        
        var childIndex = 0;
        var y = container.y;
        
        for (r in 0...rows.length) {
            var x = container.x;
            for (c in 0...columns.length) {
                if (childIndex >= children.length) break;
                if (deleted.indexOf(children[childIndex]) > -1) {
                    childIndex++;
                    continue;
                }
                
                var child = dims[children[childIndex]];
                child.x = x;
                child.y = y;
                
                x += colWidths[c];
                childIndex++;
            }
            y += rowHeights[r];
        }
    }
    
    private function calculateGridSizes(sizes:Array<GridSize>, totalSize:Float):Array<Float> {
        var fixed = 0.0;
        var percentTotal = 0.0;
        var autoCount = 0;
        
        for (size in sizes) {
            switch (size) {
                case Fixed(pixels): fixed += pixels;
                case Percent(pct): percentTotal += pct;
                case Auto: autoCount++;
            }
        }
        
        var remaining = totalSize - fixed;
        var autoSize = autoCount > 0 ? remaining * (1.0 - percentTotal) / autoCount : 0;
        var results = [];
        
        for (size in sizes) {
            results.push(switch (size) {
                case Fixed(pixels): pixels;
                case Percent(pct): pct * remaining;
                case Auto: autoSize;
            });
        }
        
        return results;
    }
    
    private function solveStack(containerIdx:Int, children:Array<Int>) {
        if (deleted.indexOf(containerIdx) > -1) return;
        
        var container = dims[containerIdx];
        var maxWidth = 0.0;
        var maxHeight = 0.0;
        
        for (childIdx in children) {
            if (deleted.indexOf(childIdx) > -1) continue;
            
            var child = dims[childIdx];
            child.x = container.x;
            child.y = container.y;
            maxWidth = Math.max(maxWidth, child.width);
            maxHeight = Math.max(maxHeight, child.height);
        }
        
        container.width = maxWidth;
        container.height = maxHeight;
    }
    
    private function solveContainer(containerIdx:Int, children:Array<Int>) {
        if (deleted.indexOf(containerIdx) > -1) return;
        
        // Container dimensions are already set, just position children relative to it
        var container = dims[containerIdx];
        
        for (childIdx in children) {
            if (deleted.indexOf(childIdx) > -1) continue;
            
            var child = dims[childIdx];
            // Children maintain their relative positions within the container
            child.x += container.x;
            child.y += container.y;
        }
    }
    
    private function solvePadding(wrapperIdx:Int, childIdx:Int, top:Float, right:Float, bottom:Float, left:Float) {
        if (deleted.indexOf(wrapperIdx) > -1 || deleted.indexOf(childIdx) > -1) return;
        
        var wrapper = dims[wrapperIdx];
        var child = dims[childIdx];
        
        wrapper.width = child.width + left + right;
        wrapper.height = child.height + top + bottom;
        
        child.x = wrapper.x + left;
        child.y = wrapper.y + top;
    }
    
    private function solveMerged(wrapperIdx:Int, children:Array<Int>) {
        if (deleted.indexOf(wrapperIdx) > -1) return;
        
        var wrapper = dims[wrapperIdx];
        var minX = Math.POSITIVE_INFINITY;
        var minY = Math.POSITIVE_INFINITY;
        var maxX = Math.NEGATIVE_INFINITY;
        var maxY = Math.NEGATIVE_INFINITY;
        
        for (childIdx in children) {
            if (deleted.indexOf(childIdx) > -1) continue;
            
            var child = dims[childIdx];
            minX = Math.min(minX, child.x);
            minY = Math.min(minY, child.y);
            maxX = Math.max(maxX, child.x + child.width);
            maxY = Math.max(maxY, child.y + child.height);
        }
        
        wrapper.x = minX;
        wrapper.y = minY;
        wrapper.width = maxX - minX;
        wrapper.height = maxY - minY;
    }
    
    private function solveAlignment(targetIdx:Int, referenceIdx:Int, alignment:LayoutAlignment) {
        if (deleted.indexOf(targetIdx) > -1) return;
        
        var target = dims[targetIdx];
        var reference = referenceIdx == -1 ? 
            new Dim(0, 0, System.windowWidth(), System.windowHeight()) : 
            dims[referenceIdx];
            
        switch (alignment) {
            case Center:
                target.x = reference.x + (reference.width - target.width) / 2;
                target.y = reference.y + (reference.height - target.height) / 2;
                
            case TopLeft:
                target.x = reference.x;
                target.y = reference.y;
                
            case TopCenter:
                target.x = reference.x + (reference.width - target.width) / 2;
                target.y = reference.y;
                
            case TopRight:
                target.x = reference.x + reference.width - target.width;
                target.y = reference.y;
                
            case MiddleLeft:
                target.x = reference.x;
                target.y = reference.y + (reference.height - target.height) / 2;
                
            case MiddleRight:
                target.x = reference.x + reference.width - target.width;
                target.y = reference.y + (reference.height - target.height) / 2;
                
            case BottomLeft:
                target.x = reference.x;
                target.y = reference.y + reference.height - target.height;
                
            case BottomCenter:
                target.x = reference.x + (reference.width - target.width) / 2;
                target.y = reference.y + reference.height - target.height;
                
            case BottomRight:
                target.x = reference.x + reference.width - target.width;
                target.y = reference.y + reference.height - target.height;
        }
    }
    
    private function updateDimension(ctx:GraphicsContext, index:DimIndex, newDim:Dim) {
        switch (index) {
            case Direct(i):
                ctx.dimensions[i].x = newDim.x;
                ctx.dimensions[i].y = newDim.y;
                ctx.dimensions[i].width = newDim.width;
                ctx.dimensions[i].height = newDim.height;
                ctx.markDimChange(index);
            case Group(g):
                // Handle group updates if needed
        }
    }
    
    private function remapConstraint(constraint:LayoutConstraint, indexMap:Map<Int, Int>):LayoutConstraint {
        return switch(constraint) {
            case HorizontalFlow(container, children, spacing):
                HorizontalFlow(
                    indexMap.exists(container) ? indexMap[container] : container,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c),
                    spacing
                );
            case VerticalFlow(container, children, spacing):
                VerticalFlow(
                    indexMap.exists(container) ? indexMap[container] : container,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c),
                    spacing
                );
            case GridLayout(container, columns, rows, children):
                GridLayout(
                    indexMap.exists(container) ? indexMap[container] : container,
                    columns,
                    rows,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c)
                );
            case StackLayout(container, children):
                StackLayout(
                    indexMap.exists(container) ? indexMap[container] : container,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c)
                );
            case ScrollContainer(container, children):
                ScrollContainer(
                    indexMap.exists(container) ? indexMap[container] : container,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c)
                );
            case ClippedContainer(container, children):
                ClippedContainer(
                    indexMap.exists(container) ? indexMap[container] : container,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c)
                );
            case Padding(wrapper, child, top, right, bottom, left):
                Padding(
                    indexMap.exists(wrapper) ? indexMap[wrapper] : wrapper,
                    indexMap.exists(child) ? indexMap[child] : child,
                    top, right, bottom, left
                );
            case MergedLayout(wrapper, children):
                MergedLayout(
                    indexMap.exists(wrapper) ? indexMap[wrapper] : wrapper,
                    children.map(c -> indexMap.exists(c) ? indexMap[c] : c)
                );
            case Align(target, reference, alignment):
                Align(
                    indexMap.exists(target) ? indexMap[target] : target,
                    reference == -1 ? -1 : (indexMap.exists(reference) ? indexMap[reference] : reference),
                    alignment
                );
            case Position(target, x, y):
                Position(
                    indexMap.exists(target) ? indexMap[target] : target,
                    x, y
                );
            case Size(target, width, height):
                Size(
                    indexMap.exists(target) ? indexMap[target] : target,
                    width, height
                );
        };
    }
}

typedef ContainerInfo = {
    index:Int,
    children:Array<Int>,
    scrollable:Bool,
    clipContent:Bool
}